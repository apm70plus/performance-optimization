# Linux性能优化

## 准备工作
- 准备一台linux服务器，本文以ubuntu服务器为例

## Linux系统常用的性能分析指标

### 系统平均负载
平均负载（load average）体现了单位时间内占用cpu时间的进程数和等待cpu时间的进程数。通过系统平均负载的值，我们可以直观的感受到系统的负荷是高还是低。参考**阮一峰**的[理解Linux系统负荷](http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html)一文，文中阮一峰的举例非常形象的表达了什么是系统负载

假设最简单的情况，你的电脑只有一个CPU，所有的运算都必须由这个CPU来完成。
不妨把这个CPU想象成一座大桥，桥上只有一根车道，所有车辆都必须从这根车道上通过。（很显然，这座桥只能单向通行。）

- 系统负荷为0，意味着大桥上一辆车也没有。  
![负荷0](http://www.ruanyifeng.com/blogimg/asset/201107/bg2011073004.png)

- 系统负荷为0.5，意味着大桥一半的路段有车。  
![负荷0.5](http://www.ruanyifeng.com/blogimg/asset/201107/bg2011073005.png)

- 系统负荷为1.0，意味着大桥的所有路段都有车，也就是说大桥已经"满"了。但是必须注意的是，直到此时大桥还是能顺畅通行的。  
![负荷1.0](http://www.ruanyifeng.com/blogimg/asset/201107/bg2011073006.png)

- 系统负荷为1.7，意味着车辆太多了，大桥已经被占满了（100%），后面等着上桥的车辆为桥面车辆的70%。以此类推，系统负荷2.0，意味着等待上桥的车辆与桥面的车辆一样多；系统负荷3.0，意味着等待上桥的车辆是桥面车辆的2倍。总之，当系统负荷大于1，后面的车辆就必须等待了；系统负荷越大，过桥就必须等得越久。  
![负荷1.7](http://www.ruanyifeng.com/blogimg/asset/201107/bg2011073007.png)

不得不佩服，阮一峰大牛将复杂问题讲述的如此的简单透彻。对单核cpu而言，负载为1.0就说明需要处理的进程数刚刚好契合cpu的最大处理能力，对cpu的压榨达到极限而刚刚好还没有出现排队等待的进程。负载小于1.0说明cpu还有空闲。负载大于1.0说明cpu被压榨到极限仍然无法满足进程的请求，系统出现排队拥堵现象，必须尽快疏导。

对于多核处理器而言，系统负载值要根据核心数翻倍，n核心cpu，可接受的系统负载最大值就是n x 1.0

- 系统负荷的经验法则
  - 当系统负荷持续大于0.7，你必须开始调查了，问题出在哪里，防止情况恶化。
  - 当系统负荷持续大于1.0，你必须动手寻找解决办法，把这个值降下来。
  - 当系统负荷达到5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。
  
### CPU使用率
cpu使用率反映的是cpu当前时间的繁忙程度。  

那么它和系统平均负载又有什么区别呢？系统负载反映的是系统对请求进程的处理情况，在单位时间内，是否能处理完所有的请求进程，是还有富余还是已经出现排队，这与cpu使用率不一定有直接关联。因为有的进程是cpu密集型的处理，有的进程是io密集型的处理，这两类进程都可能导致系统平均负载过高。

### IO wait
**iowait** 表示在一个采样周期内有百分之几的时间属于以下情况：**CPU空闲**、并且**有仍未完成的I/O请求**。  
注意，必要条件是cpu要空闲，此时未完成的IO请求才计入iowait。  
在CPU繁忙期间发生的I/O，无论IO是多还是少，%iowait都不会变；当CPU繁忙程度下降时，有一部分IO落入CPU空闲时间段内，导致%iowait升高。

### 小结

如下情况可能导致平均负载增高  
- cpu密集型的进程，使用大量cpu会导致平均负载增高，此时cpu使用率也很高
- io密集型的进程，等待io会导致平均负载增高，此时cpu使用率不一定高，iowait往往比较高
- 大量等待处理的进程会导致平均负载很高（超过1.0 x n）

## 诊断工具
安装sysstat包（sudo apt install sysstat)  
工欲善其事，必先利其器。要诊断Linux性能问题，有了合适的工具，才能起到事半功倍的效果。下面来介绍linux下常用的性能诊断工具

- uptime 是常用的查看系统平均负载的工具。打印的最后三个数值是最近1分钟、5分钟、15分钟内的系统平均负载情况
- mpstat 是常用的多核心cpu性能分析工具。用来实时查看每个cup的性能指标和所有cpu的平均指标
- pidstat 是常用的进程性能分析工具。用来实时查看进程的cpu、内存、io、上下文切换等性能指标

下面我们结合上面的三个命令来讲解如何分析系统性能问题

- 用stress模拟一个cpu 100%使用率的场景  
```
stress --cpu 1 --timeout 600
```

- 运行uptime查看平均负载情况  
```
watch -d uptime
16:57:20 up  7:02,  1 user,  load average: 0.92, 0.50, 0.41
```

我们看到最近一分钟的平均负载达到了0.92，接近单cpu满负荷，而最近5分钟平均负载是0.50，最近15分钟是0.41，说明这段时间的系统负载一直在上升，并且上升很快。如果15分钟内平均负载高与最近1分钟内平均负载，则说明系统负载呈下降趋势。

- 运行mpstat查看cpu使用率的变化情况。 -P ALL表示监视所有cpu，后面数字5表示间隔5秒输出一次最新数据  
```
mpstat -P ALL 5
Linux 4.15.0-39-generic (liuyg-T400) 	2018年12月05日 	_x86_64_	(2 CPU)

17时10分57秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
17时11分02秒  all   25.08    0.00    2.11    0.10    0.00    0.00    0.00    0.00    0.00   72.72
17时11分02秒    0    4.40    0.00    2.60    0.00    0.00    0.00    0.00    0.00    0.00   93.00
17时11分02秒    1   46.06    0.00    1.41    0.20    0.00    0.00    0.00    0.00    0.00   52.32

17时11分02秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
17时11分07秒  all   53.85    0.00    2.80    0.00    0.00    0.00    0.00    0.00    0.00   43.36
17时11分07秒    0   15.94    0.00    3.98    0.00    0.00    0.00    0.00    0.00    0.00   80.08
17时11分07秒    1   91.80    0.00    1.80    0.00    0.00    0.00    0.00    0.00    0.00    6.40

17时11分07秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
17时11分12秒  all   58.40    0.00    3.60    0.00    0.00    0.00    0.00    0.00    0.00   38.00
17时11分12秒    0   17.80    0.00    6.20    0.00    0.00    0.00    0.00    0.00    0.00   76.00
17时11分12秒    1   99.00    0.00    0.80    0.00    0.00    0.00    0.00    0.00    0.00    0.20

```

首先需要了解cpu使用率的十个指标都代表什么含义  
- user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了guest时间 
- nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低
- system（通常缩写为 sys），代表内核态 CPU 时间
- idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）
- iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间
- irq（通常缩写为 hi），代表处理硬中断的 CPU 时间
- softirq（通常缩写为 si），代表处理软中断的 CPU 时间
- steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间
- guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的CPU时间 
- guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间

我们看到cpu1的使用率逐渐上升达到接近100%，而iowait是0.00，这与uptime观察到的系统平均负载接近1.0是一致的，说明导致系统负载高的原因是cpu使用率过高导致的

- 接下来我们要进一步定位是哪个进程导致cpu使用率过高。这时候就要用到pidstat来查看, -u 表示输出cpu使用率，最后的数字5 1表示输出间隔5秒，输出1次（top命令也有类似功效）  
```
pidstat -u 5 1

平均时间:   UID       PID    %usr %system  %guest    %CPU   CPU  Command
平均时间:     0       285    0.00    0.40    0.00    0.40     -  systemd-udevd
平均时间:     0       905    0.20    0.00    0.00    0.20     -  snapd
平均时间:     0      1077    0.00    0.40    0.00    0.40     -  Xorg
平均时间:  1000      3217    0.20    0.00    0.00    0.20     -  upstart
平均时间:  1000      3543    0.20    0.00    0.00    0.20     -  gnome-shell
平均时间:     0      3746    0.20    0.00    0.00    0.20     -  fwupd
平均时间:  1000     12417    0.20    0.00    0.00    0.20     -  chrome
平均时间:     0     13770   99.20    0.00    0.00   99.20     -  stress
平均时间:     0     13952    0.00    0.20    0.00    0.20     -  pidstat
平均时间:  1000     17240    0.00    0.20    0.00    0.20     -  gnome-terminal-
平均时间:  1000     18053    0.20    0.00    0.00    0.20     -  electronic-wech
平均时间:  1000     18103    0.60    0.00    0.00    0.60     -  electronic-wech

```

我们通过Command列可以看到，是stress进程导致cpu使用率升高。至此我们已经找到是哪个进程（程序）导致cpu使用率过高，接下来呢？如果是我们自己的程序，我们肯定希望知道是


